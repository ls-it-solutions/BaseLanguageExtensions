package jetbrains.mps.baseLanguage.memoize.util.caches;

/*Generated by MPS */

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.MapSequence;

public class Memoizator {
  public Memoizator() {
  }

  public static Map<Integer, Object> buildMemoizeCache(int sizeLimit) {
    if (sizeLimit < 0) {
      throw new IllegalArgumentException("A non-negative number is required as the fixed cache size parameter for memoize.");
    }

    if (sizeLimit == 0) {
      return Memoizator.createMap();
    } else {
      return buildBoundedMemoizeCache(sizeLimit);
    }
  }

  private static ConcurrentHashMap<Integer, Object> createMap() {
    return new ConcurrentHashMap<Integer, Object>();
  }

  private static Map<Integer, Object> buildBoundedMemoizeCache(int fixedSize) {
    Map storage = new LRUProtectionStorage(fixedSize);
    return Collections.synchronizedMap(storage);
  }

  public static Object retrieveFromCache(Map<Integer, Object> cache, KeyCalculator key) {
    if (cache == null) {
      throw new IllegalStateException("Cannot use a null cache for memoize");
    }
    return MapSequence.fromMap(cache).get(key.getKey());
  }

  public static void storeInCache(Map<Integer, Object> cache, KeyCalculator key, Object value) {
    if (cache == null) {
      throw new IllegalStateException("Cannot use a null cache for memoize");
    }
    if (value == null) {
      throw new IllegalArgumentException("Cannot store null values in memoize cache");
    }
    MapSequence.fromMap(cache).put(key.getKey(), value);
  }
}
